/**
 * @fileoverview 月度成本分攤報告服務
 * @description
 *   提供月度成本報告的生成、管理與下載功能：
 *   - 報告生成（聚合月度數據）
 *   - Excel 報告生成（多工作表）
 *   - PDF 報告生成（摘要頁面）
 *   - 報告歷史管理
 *   - 報告下載連結生成
 *
 * @module src/services/monthly-cost-report.service
 * @since Epic 7 - Story 7.10 (月度成本分攤報告)
 * @lastModified 2025-12-20
 *
 * @features
 *   - AC1: 月度報告數據聚合
 *   - AC2: Excel 報告生成（4個工作表）
 *   - AC3: PDF 報告生成
 *   - AC4: 報告歷史管理
 *   - AC5: 報告下載（簽名 URL）
 *
 * @dependencies
 *   - @/lib/prisma - 資料庫客戶端
 *   - @/lib/azure-blob - Azure Blob Storage
 *   - exceljs - Excel 生成
 *   - pdfkit - PDF 生成
 *   - @/types/monthly-report - 類型定義
 */

import { prisma } from '@/lib/prisma'
import { uploadBufferToBlob, generateSignedUrl } from '@/lib/azure-blob'
import type {
  MonthlyReportData,
  MonthlyReportRecord,
  MonthlyReportSummary,
  CityBreakdownItem,
  ApiCostBreakdownItem,
  DailyTrendItem,
  ReportFormat,
} from '@/types/monthly-report'
import {
  DEFAULT_COST_PER_MANUAL_REVIEW,
  DEFAULT_MANUAL_REVIEW_RATE,
  REPORT_EXPIRY_DAYS,
} from '@/types/monthly-report'
import ExcelJS from 'exceljs'
import PDFDocument from 'pdfkit'

// ============================================================
// Types
// ============================================================

interface CityStats {
  cityCode: string
  volume: number
  aiCost: number
  laborCost: number
  totalCost: number
}

interface PreviousMonthStats {
  totalCost: number
  totalVolume: number
  avgCostPerDoc: number
  cities: CityStats[]
}

// ============================================================
// MonthlyCostReportService Class
// ============================================================

/**
 * 月度成本報告服務
 *
 * @description
 *   使用 Singleton 模式，提供月度報告的完整功能
 */
export class MonthlyCostReportService {
  private static instance: MonthlyCostReportService

  static getInstance(): MonthlyCostReportService {
    if (!this.instance) {
      this.instance = new MonthlyCostReportService()
    }
    return this.instance
  }

  /**
   * 生成月度報告
   *
   * @param month - 月份 (YYYY-MM)
   * @param formats - 報告格式（excel/pdf）
   * @param generatedBy - 生成者 ID
   * @param isAutoGenerated - 是否自動生成
   * @returns 報告記錄
   */
  async generateReport(
    month: string,
    formats: ReportFormat[],
    generatedBy?: string,
    isAutoGenerated = false
  ): Promise<MonthlyReportRecord> {
    const { startDate, endDate } = this.parseMonth(month)

    // 創建或更新報告記錄
    const report = await prisma.monthlyReport.upsert({
      where: {
        reportMonth_reportType: {
          reportMonth: startDate,
          reportType: 'COST_ALLOCATION',
        },
      },
      create: {
        reportMonth: startDate,
        status: 'GENERATING',
        generatedBy,
        isAutoGenerated,
      },
      update: {
        status: 'GENERATING',
        generatedBy,
        isAutoGenerated,
        errorMessage: null,
      },
    })

    try {
      // 收集報告數據
      const reportData = await this.collectReportData(startDate, endDate)

      // 生成檔案
      const { excelPath, pdfPath } = await this.generateReportFiles(
        reportData,
        month,
        formats
      )

      // 計算過期時間
      const expiresAt = new Date()
      expiresAt.setDate(expiresAt.getDate() + REPORT_EXPIRY_DAYS)

      // 更新報告記錄
      const updated = await prisma.monthlyReport.update({
        where: { id: report.id },
        data: {
          status: 'COMPLETED',
          totalCost: reportData.summary.totalCost,
          totalVolume: reportData.summary.totalVolume,
          cityCount: reportData.summary.cityCount,
          summaryData: reportData.summary as object,
          excelPath,
          pdfPath,
          generatedAt: new Date(),
          expiresAt,
        },
        include: { generatedByUser: { select: { name: true } } },
      })

      return this.toReportRecord(updated)
    } catch (error) {
      await prisma.monthlyReport.update({
        where: { id: report.id },
        data: {
          status: 'FAILED',
          errorMessage: error instanceof Error ? error.message : 'Unknown error',
        },
      })
      throw error
    }
  }

  /**
   * 收集報告數據
   */
  private async collectReportData(
    startDate: Date,
    endDate: Date
  ): Promise<MonthlyReportData> {
    const [cities, cityStats, apiStats, dailyTrend, prevMonthStats] =
      await Promise.all([
        prisma.city.findMany({ include: { region: { select: { name: true } } } }),
        this.getCityStats(startDate, endDate),
        this.getApiStats(startDate, endDate),
        this.getDailyTrend(startDate, endDate),
        this.getPreviousMonthStats(startDate),
      ])

    // 計算總覽
    const totalCost = cityStats.reduce((sum, c) => sum + c.totalCost, 0)
    const totalVolume = cityStats.reduce((sum, c) => sum + c.volume, 0)
    const totalAiCost = cityStats.reduce((sum, c) => sum + c.aiCost, 0)
    const totalLaborCost = cityStats.reduce((sum, c) => sum + c.laborCost, 0)

    // 組裝城市明細
    const cityMap = new Map(cities.map((c) => [c.code, c]))
    const cityBreakdown: CityBreakdownItem[] = cityStats
      .map((stat) => {
        const city = cityMap.get(stat.cityCode)
        const prevCity = prevMonthStats.cities.find(
          (p) => p.cityCode === stat.cityCode
        )

        return {
          cityCode: stat.cityCode,
          cityName: city?.name || stat.cityCode,
          regionName: city?.region?.name,
          volume: stat.volume,
          volumePercentage:
            totalVolume > 0 ? (stat.volume / totalVolume) * 100 : 0,
          aiCost: stat.aiCost,
          laborCost: stat.laborCost,
          totalCost: stat.totalCost,
          costPercentage:
            totalCost > 0 ? (stat.totalCost / totalCost) * 100 : 0,
          costPerDocument: stat.volume > 0 ? stat.totalCost / stat.volume : 0,
          comparedToPreviousMonth: {
            costChange: prevCity?.totalCost
              ? ((stat.totalCost - prevCity.totalCost) / prevCity.totalCost) *
                100
              : 0,
            volumeChange: prevCity?.volume
              ? ((stat.volume - prevCity.volume) / prevCity.volume) * 100
              : 0,
          },
        }
      })
      .sort((a, b) => b.totalCost - a.totalCost)

    const avgCostPerDocument = totalVolume > 0 ? totalCost / totalVolume : 0

    const summary: MonthlyReportSummary = {
      totalCost,
      totalVolume,
      totalAiCost,
      totalLaborCost,
      avgCostPerDocument,
      cityCount: cityBreakdown.length,
      comparedToPreviousMonth: {
        costChange:
          prevMonthStats.totalCost > 0
            ? ((totalCost - prevMonthStats.totalCost) /
                prevMonthStats.totalCost) *
              100
            : 0,
        volumeChange:
          prevMonthStats.totalVolume > 0
            ? ((totalVolume - prevMonthStats.totalVolume) /
                prevMonthStats.totalVolume) *
              100
            : 0,
        costPerDocChange:
          prevMonthStats.avgCostPerDoc > 0
            ? ((avgCostPerDocument - prevMonthStats.avgCostPerDoc) /
                prevMonthStats.avgCostPerDoc) *
              100
            : 0,
      },
    }

    return {
      reportMonth: this.formatMonth(startDate),
      generatedAt: new Date().toISOString(),
      summary,
      cityBreakdown,
      apiCostBreakdown: apiStats,
      dailyTrend,
    }
  }

  /**
   * 獲取城市統計
   */
  private async getCityStats(
    startDate: Date,
    endDate: Date
  ): Promise<CityStats[]> {
    const stats = await prisma.$queryRaw<
      Array<{
        cityCode: string
        volume: bigint
        aiCost: number
      }>
    >`
      SELECT
        city_code as "cityCode",
        COUNT(*)::bigint as volume,
        COALESCE(SUM(ai_cost), 0)::float as "aiCost"
      FROM documents
      WHERE created_at >= ${startDate} AND created_at <= ${endDate}
        AND city_code IS NOT NULL
      GROUP BY city_code
    `

    return stats.map((s) => ({
      cityCode: s.cityCode,
      volume: Number(s.volume),
      aiCost: s.aiCost,
      laborCost: this.estimateLaborCost(Number(s.volume)),
      totalCost: s.aiCost + this.estimateLaborCost(Number(s.volume)),
    }))
  }

  /**
   * 估算人工成本
   */
  private estimateLaborCost(volume: number): number {
    return volume * DEFAULT_MANUAL_REVIEW_RATE * DEFAULT_COST_PER_MANUAL_REVIEW
  }

  /**
   * 獲取 API 統計
   */
  private async getApiStats(
    startDate: Date,
    endDate: Date
  ): Promise<ApiCostBreakdownItem[]> {
    const stats = await prisma.apiUsageLog.groupBy({
      by: ['provider'],
      where: { createdAt: { gte: startDate, lte: endDate } },
      _sum: { estimatedCost: true, tokensInput: true, tokensOutput: true },
      _count: { id: true },
    })

    const total = stats.reduce(
      (sum, s) => sum + Number(s._sum.estimatedCost || 0),
      0
    )

    return stats.map((s) => {
      const cost = Number(s._sum.estimatedCost || 0)
      return {
        provider: s.provider,
        calls: s._count.id,
        tokens: {
          input: s._sum.tokensInput || 0,
          output: s._sum.tokensOutput || 0,
        },
        cost,
        percentage: total > 0 ? (cost / total) * 100 : 0,
      }
    })
  }

  /**
   * 獲取每日趨勢
   */
  private async getDailyTrend(
    startDate: Date,
    endDate: Date
  ): Promise<DailyTrendItem[]> {
    const trend = await prisma.$queryRaw<
      Array<{
        date: Date
        volume: bigint
        cost: number
      }>
    >`
      SELECT
        DATE(created_at) as date,
        COUNT(*)::bigint as volume,
        COALESCE(SUM(ai_cost), 0)::float as cost
      FROM documents
      WHERE created_at >= ${startDate} AND created_at <= ${endDate}
      GROUP BY DATE(created_at)
      ORDER BY date
    `

    return trend.map((t) => ({
      date: t.date.toISOString().split('T')[0],
      volume: Number(t.volume),
      cost: t.cost,
    }))
  }

  /**
   * 獲取上月統計
   */
  private async getPreviousMonthStats(
    currentMonthStart: Date
  ): Promise<PreviousMonthStats> {
    const prevStart = new Date(currentMonthStart)
    prevStart.setMonth(prevStart.getMonth() - 1)
    const prevEnd = new Date(currentMonthStart)
    prevEnd.setDate(prevEnd.getDate() - 1)
    prevEnd.setHours(23, 59, 59, 999)

    const cityStats = await this.getCityStats(prevStart, prevEnd)
    const totalCost = cityStats.reduce((sum, c) => sum + c.totalCost, 0)
    const totalVolume = cityStats.reduce((sum, c) => sum + c.volume, 0)

    return {
      totalCost,
      totalVolume,
      avgCostPerDoc: totalVolume > 0 ? totalCost / totalVolume : 0,
      cities: cityStats,
    }
  }

  /**
   * 生成報告檔案
   */
  private async generateReportFiles(
    data: MonthlyReportData,
    month: string,
    formats: ReportFormat[]
  ): Promise<{ excelPath?: string; pdfPath?: string }> {
    let excelPath: string | undefined
    let pdfPath: string | undefined

    if (formats.includes('excel')) {
      const buffer = await this.generateExcelReport(data)
      excelPath = await uploadBufferToBlob(
        buffer,
        `reports/monthly-cost-${month}.xlsx`,
        'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
      )
    }

    if (formats.includes('pdf')) {
      const buffer = await this.generatePdfReport(data)
      pdfPath = await uploadBufferToBlob(
        buffer,
        `reports/monthly-cost-${month}.pdf`,
        'application/pdf'
      )
    }

    return { excelPath, pdfPath }
  }

  /**
   * 生成 Excel 報告
   */
  private async generateExcelReport(data: MonthlyReportData): Promise<Buffer> {
    const workbook = new ExcelJS.Workbook()
    workbook.creator = 'AI Document Extraction System'
    workbook.created = new Date()

    // 1. 摘要工作表
    this.buildSummarySheet(workbook.addWorksheet('摘要'), data)

    // 2. 城市明細工作表
    this.buildCitySheet(workbook.addWorksheet('城市明細'), data)

    // 3. API 成本工作表
    this.buildApiSheet(workbook.addWorksheet('API 成本'), data)

    // 4. 每日趨勢工作表
    this.buildTrendSheet(workbook.addWorksheet('每日趨勢'), data)

    return Buffer.from(await workbook.xlsx.writeBuffer())
  }

  /**
   * 建構摘要工作表
   */
  private buildSummarySheet(
    sheet: ExcelJS.Worksheet,
    data: MonthlyReportData
  ): void {
    // 標題
    sheet.mergeCells('A1:C1')
    sheet.getCell('A1').value = `月度成本分攤報告 - ${data.reportMonth}`
    sheet.getCell('A1').font = { bold: true, size: 16 }
    sheet.getCell('A1').alignment = { horizontal: 'center' }

    // 表頭
    sheet.getRow(3).values = ['指標', '數值', '較上月']
    sheet.getRow(3).font = { bold: true }
    sheet.getRow(3).fill = {
      type: 'pattern',
      pattern: 'solid',
      fgColor: { argb: 'FFE0E0E0' },
    }

    // 數據行
    const rows = [
      [
        '總成本 (USD)',
        `$${data.summary.totalCost.toFixed(2)}`,
        `${data.summary.comparedToPreviousMonth.costChange >= 0 ? '+' : ''}${data.summary.comparedToPreviousMonth.costChange.toFixed(1)}%`,
      ],
      [
        '總處理量',
        data.summary.totalVolume.toLocaleString(),
        `${data.summary.comparedToPreviousMonth.volumeChange >= 0 ? '+' : ''}${data.summary.comparedToPreviousMonth.volumeChange.toFixed(1)}%`,
      ],
      ['AI 成本', `$${data.summary.totalAiCost.toFixed(2)}`, ''],
      ['人工成本（估算）', `$${data.summary.totalLaborCost.toFixed(2)}`, ''],
      [
        '平均單位成本',
        `$${data.summary.avgCostPerDocument.toFixed(4)}`,
        `${data.summary.comparedToPreviousMonth.costPerDocChange >= 0 ? '+' : ''}${data.summary.comparedToPreviousMonth.costPerDocChange.toFixed(1)}%`,
      ],
      ['城市數', data.summary.cityCount.toString(), ''],
    ]

    rows.forEach((row, i) => {
      sheet.getRow(i + 4).values = row
    })

    // 設置列寬
    sheet.columns = [{ width: 25 }, { width: 20 }, { width: 15 }]
  }

  /**
   * 建構城市明細工作表
   */
  private buildCitySheet(
    sheet: ExcelJS.Worksheet,
    data: MonthlyReportData
  ): void {
    sheet.columns = [
      { header: '城市', key: 'cityName', width: 20 },
      { header: '區域', key: 'regionName', width: 15 },
      { header: '處理量', key: 'volume', width: 12 },
      { header: '處理量占比', key: 'volumePct', width: 12 },
      { header: 'AI 成本', key: 'aiCost', width: 12 },
      { header: '人工成本', key: 'laborCost', width: 12 },
      { header: '總成本', key: 'totalCost', width: 12 },
      { header: '成本占比', key: 'costPct', width: 12 },
      { header: '單位成本', key: 'costPerDoc', width: 12 },
      { header: '成本變化', key: 'costChange', width: 12 },
    ]

    data.cityBreakdown.forEach((city) => {
      sheet.addRow({
        cityName: city.cityName,
        regionName: city.regionName || '',
        volume: city.volume,
        volumePct: `${city.volumePercentage.toFixed(1)}%`,
        aiCost: `$${city.aiCost.toFixed(2)}`,
        laborCost: `$${city.laborCost.toFixed(2)}`,
        totalCost: `$${city.totalCost.toFixed(2)}`,
        costPct: `${city.costPercentage.toFixed(1)}%`,
        costPerDoc: `$${city.costPerDocument.toFixed(4)}`,
        costChange: `${city.comparedToPreviousMonth.costChange >= 0 ? '+' : ''}${city.comparedToPreviousMonth.costChange.toFixed(1)}%`,
      })
    })

    // 樣式
    sheet.getRow(1).font = { bold: true }
    sheet.getRow(1).fill = {
      type: 'pattern',
      pattern: 'solid',
      fgColor: { argb: 'FFE0E0E0' },
    }

    // 篩選
    sheet.autoFilter = { from: 'A1', to: 'J1' }
  }

  /**
   * 建構 API 成本工作表
   */
  private buildApiSheet(
    sheet: ExcelJS.Worksheet,
    data: MonthlyReportData
  ): void {
    sheet.columns = [
      { header: 'API 供應商', key: 'provider', width: 25 },
      { header: '調用次數', key: 'calls', width: 15 },
      { header: '輸入 Tokens', key: 'tokensInput', width: 15 },
      { header: '輸出 Tokens', key: 'tokensOutput', width: 15 },
      { header: '成本 (USD)', key: 'cost', width: 15 },
      { header: '占比', key: 'percentage', width: 10 },
    ]

    data.apiCostBreakdown.forEach((api) => {
      sheet.addRow({
        provider: api.provider,
        calls: api.calls.toLocaleString(),
        tokensInput: api.tokens.input.toLocaleString(),
        tokensOutput: api.tokens.output.toLocaleString(),
        cost: `$${api.cost.toFixed(2)}`,
        percentage: `${api.percentage.toFixed(1)}%`,
      })
    })

    sheet.getRow(1).font = { bold: true }
    sheet.getRow(1).fill = {
      type: 'pattern',
      pattern: 'solid',
      fgColor: { argb: 'FFE0E0E0' },
    }
  }

  /**
   * 建構每日趨勢工作表
   */
  private buildTrendSheet(
    sheet: ExcelJS.Worksheet,
    data: MonthlyReportData
  ): void {
    sheet.columns = [
      { header: '日期', key: 'date', width: 15 },
      { header: '處理量', key: 'volume', width: 12 },
      { header: '成本 (USD)', key: 'cost', width: 15 },
    ]

    data.dailyTrend.forEach((day) => {
      sheet.addRow({
        date: day.date,
        volume: day.volume,
        cost: `$${day.cost.toFixed(2)}`,
      })
    })

    sheet.getRow(1).font = { bold: true }
  }

  /**
   * 生成 PDF 報告
   */
  private async generatePdfReport(data: MonthlyReportData): Promise<Buffer> {
    return new Promise((resolve, reject) => {
      const chunks: Buffer[] = []
      const doc = new PDFDocument({
        margin: 50,
        size: 'A4',
      })

      doc.on('data', (chunk: Buffer) => chunks.push(chunk))
      doc.on('end', () => resolve(Buffer.concat(chunks)))
      doc.on('error', reject)

      // 標題頁
      this.buildPdfTitlePage(doc, data)

      // 摘要頁
      doc.addPage()
      this.buildPdfSummaryPage(doc, data)

      // 城市排名頁
      doc.addPage()
      this.buildPdfCityRankingPage(doc, data)

      // API 成本頁
      doc.addPage()
      this.buildPdfApiCostPage(doc, data)

      // 頁尾
      this.addPdfFooter(doc, data)

      doc.end()
    })
  }

  /**
   * 建構 PDF 標題頁
   */
  private buildPdfTitlePage(
    doc: PDFKit.PDFDocument,
    data: MonthlyReportData
  ): void {
    doc
      .fontSize(28)
      .font('Helvetica-Bold')
      .text('Monthly Cost Allocation Report', { align: 'center' })

    doc.moveDown(2)
    doc
      .fontSize(20)
      .font('Helvetica')
      .text(data.reportMonth, { align: 'center' })

    doc.moveDown(4)
    doc
      .fontSize(12)
      .text(`Generated: ${new Date().toLocaleString('en-US')}`, {
        align: 'center',
      })
  }

  /**
   * 建構 PDF 摘要頁
   */
  private buildPdfSummaryPage(
    doc: PDFKit.PDFDocument,
    data: MonthlyReportData
  ): void {
    doc.fontSize(18).font('Helvetica-Bold').text('Executive Summary')
    doc.moveDown()

    const summaryItems = [
      {
        label: 'Total Cost',
        value: `$${data.summary.totalCost.toFixed(2)}`,
        change: data.summary.comparedToPreviousMonth.costChange,
      },
      {
        label: 'Total Volume',
        value: data.summary.totalVolume.toLocaleString(),
        change: data.summary.comparedToPreviousMonth.volumeChange,
      },
      {
        label: 'AI Cost',
        value: `$${data.summary.totalAiCost.toFixed(2)}`,
      },
      {
        label: 'Labor Cost (Est.)',
        value: `$${data.summary.totalLaborCost.toFixed(2)}`,
      },
      {
        label: 'Avg Cost per Document',
        value: `$${data.summary.avgCostPerDocument.toFixed(4)}`,
        change: data.summary.comparedToPreviousMonth.costPerDocChange,
      },
      {
        label: 'City Count',
        value: data.summary.cityCount.toString(),
      },
    ]

    doc.fontSize(12).font('Helvetica')
    summaryItems.forEach((item) => {
      let text = `${item.label}: ${item.value}`
      if (item.change !== undefined) {
        const sign = item.change >= 0 ? '+' : ''
        text += ` (${sign}${item.change.toFixed(1)}% vs last month)`
      }
      doc.text(text)
      doc.moveDown(0.5)
    })
  }

  /**
   * 建構 PDF 城市排名頁
   */
  private buildPdfCityRankingPage(
    doc: PDFKit.PDFDocument,
    data: MonthlyReportData
  ): void {
    doc.fontSize(18).font('Helvetica-Bold').text('City Cost Ranking (Top 15)')
    doc.moveDown()

    const top15 = data.cityBreakdown.slice(0, 15)
    doc.fontSize(10).font('Helvetica')

    top15.forEach((city, i) => {
      const rank = `${i + 1}.`.padEnd(4)
      const name = city.cityName.padEnd(15)
      const cost = `$${city.totalCost.toFixed(2)}`.padStart(12)
      const pct = `(${city.costPercentage.toFixed(1)}%)`.padStart(8)

      doc.text(`${rank}${name}${cost} ${pct}`)
      doc.moveDown(0.3)
    })
  }

  /**
   * 建構 PDF API 成本頁
   */
  private buildPdfApiCostPage(
    doc: PDFKit.PDFDocument,
    data: MonthlyReportData
  ): void {
    doc.fontSize(18).font('Helvetica-Bold').text('API Cost Breakdown')
    doc.moveDown()

    doc.fontSize(10).font('Helvetica')
    data.apiCostBreakdown.forEach((api) => {
      doc.text(`${api.provider}:`)
      doc.text(`  Calls: ${api.calls.toLocaleString()}`, { indent: 20 })
      doc.text(
        `  Cost: $${api.cost.toFixed(2)} (${api.percentage.toFixed(1)}%)`,
        { indent: 20 }
      )
      doc.moveDown(0.5)
    })
  }

  /**
   * 添加 PDF 頁尾
   */
  private addPdfFooter(
    doc: PDFKit.PDFDocument,
    data: MonthlyReportData
  ): void {
    const pages = doc.bufferedPageRange()
    for (let i = 0; i < pages.count; i++) {
      doc.switchToPage(i)
      doc
        .fontSize(8)
        .text(
          `AI Document Extraction System - ${data.reportMonth} | Page ${i + 1} of ${pages.count}`,
          50,
          doc.page.height - 30,
          { align: 'center', width: doc.page.width - 100 }
        )
    }
  }

  /**
   * 獲取報告歷史
   */
  async getReportHistory(
    page = 1,
    pageSize = 12
  ): Promise<{ reports: MonthlyReportRecord[]; total: number }> {
    const [reports, total] = await Promise.all([
      prisma.monthlyReport.findMany({
        where: { reportType: 'COST_ALLOCATION' },
        orderBy: { reportMonth: 'desc' },
        skip: (page - 1) * pageSize,
        take: pageSize,
        include: { generatedByUser: { select: { name: true } } },
      }),
      prisma.monthlyReport.count({
        where: { reportType: 'COST_ALLOCATION' },
      }),
    ])

    return {
      reports: reports.map((r) => this.toReportRecord(r)),
      total,
    }
  }

  /**
   * 獲取下載連結
   */
  async getDownloadUrl(
    reportId: string,
    format: ReportFormat
  ): Promise<{ url: string; fileName: string; expiresAt: Date } | null> {
    const report = await prisma.monthlyReport.findUnique({
      where: { id: reportId },
    })

    if (!report || report.status !== 'COMPLETED') return null

    const path = format === 'excel' ? report.excelPath : report.pdfPath
    if (!path) return null

    const expiresAt = new Date()
    expiresAt.setHours(expiresAt.getHours() + 1)

    const month = this.formatMonth(report.reportMonth)
    const fileName = `monthly-cost-${month}.${format === 'excel' ? 'xlsx' : 'pdf'}`

    return {
      url: await generateSignedUrl(path, expiresAt),
      fileName,
      expiresAt,
    }
  }

  // ============================================================
  // Helper Methods
  // ============================================================

  private parseMonth(month: string): { startDate: Date; endDate: Date } {
    const [year, monthNum] = month.split('-').map(Number)
    const startDate = new Date(year, monthNum - 1, 1)
    const endDate = new Date(year, monthNum, 0, 23, 59, 59, 999)
    return { startDate, endDate }
  }

  private formatMonth(date: Date): string {
    return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`
  }

  private toReportRecord(report: {
    id: string
    reportMonth: Date
    status: string
    totalCost: number | null
    totalVolume: number | null
    cityCount: number | null
    excelPath: string | null
    pdfPath: string | null
    generatedAt: Date | null
    generatedBy: string | null
    generatedByUser?: { name: string | null } | null
    isAutoGenerated: boolean
    errorMessage: string | null
    createdAt: Date
  }): MonthlyReportRecord {
    return {
      id: report.id,
      reportMonth: this.formatMonth(report.reportMonth),
      status: report.status as MonthlyReportRecord['status'],
      totalCost: report.totalCost ?? undefined,
      totalVolume: report.totalVolume ?? undefined,
      cityCount: report.cityCount ?? undefined,
      excelAvailable: !!report.excelPath,
      pdfAvailable: !!report.pdfPath,
      generatedAt: report.generatedAt?.toISOString(),
      generatedBy: report.generatedBy ?? undefined,
      generatedByName: report.generatedByUser?.name ?? undefined,
      isAutoGenerated: report.isAutoGenerated,
      errorMessage: report.errorMessage ?? undefined,
      createdAt: report.createdAt.toISOString(),
    }
  }
}

// ============================================================
// Export Singleton Instance
// ============================================================

export const monthlyCostReportService = MonthlyCostReportService.getInstance()
