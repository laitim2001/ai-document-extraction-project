# Tech Spec: Story 7-10 月度成本分攤報告

## Story 資訊

| 屬性 | 值 |
|------|-----|
| Story ID | 7.10 |
| Epic | Epic 7: 報表儀表板與成本追蹤 |
| 優先級 | High |
| 預估點數 | 8 |
| 狀態 | Ready for Dev |
| 依賴 | Story 7-7, 7-8, 7-9 |

## 1. 概述

### 1.1 目標
為財務人員提供月度成本分攤報告生成功能，支援多格式匯出、報告歷史管理和自動排程生成，以進行內部成本結算。

### 1.2 範圍
- 月度報告數據聚合服務
- Excel/PDF 多格式報告生成
- 報告歷史管理與下載
- 自動生成排程任務
- 報告生成 UI 對話框

### 1.3 用戶故事
**As a** 財務人員
**I want** 生成月度成本分攤報告
**So that** 可以進行內部成本結算

---

## 2. 數據庫設計

### 2.1 MonthlyReport 模型

```prisma
// prisma/schema.prisma

model MonthlyReport {
  id              String       @id @default(uuid())
  reportMonth     DateTime     @map("report_month") @db.Date
  reportType      String       @default("COST_ALLOCATION") @map("report_type")
  status          ReportStatus @default(PENDING)
  generatedBy     String?      @map("generated_by")
  isAutoGenerated Boolean      @default(false) @map("is_auto_generated")

  // 報告摘要
  totalCost       Float?       @map("total_cost")
  totalVolume     Int?         @map("total_volume")
  cityCount       Int?         @map("city_count")
  summaryData     Json?        @map("summary_data")

  // 檔案路徑
  excelPath       String?      @map("excel_path")
  pdfPath         String?      @map("pdf_path")

  // 時間戳
  createdAt       DateTime     @default(now()) @map("created_at")
  generatedAt     DateTime?    @map("generated_at")
  expiresAt       DateTime?    @map("expires_at")

  // 錯誤資訊
  errorMessage    String?      @map("error_message")

  generatedByUser User?        @relation(fields: [generatedBy], references: [id])

  @@unique([reportMonth, reportType])
  @@index([reportMonth])
  @@index([status])
  @@map("monthly_reports")
}

enum ReportStatus {
  PENDING
  GENERATING
  COMPLETED
  FAILED
}
```

### 2.2 遷移腳本

```sql
-- CreateEnum
CREATE TYPE "ReportStatus" AS ENUM ('PENDING', 'GENERATING', 'COMPLETED', 'FAILED');

-- CreateTable
CREATE TABLE "monthly_reports" (
    "id" UUID NOT NULL DEFAULT gen_random_uuid(),
    "report_month" DATE NOT NULL,
    "report_type" VARCHAR(50) NOT NULL DEFAULT 'COST_ALLOCATION',
    "status" "ReportStatus" NOT NULL DEFAULT 'PENDING',
    "generated_by" UUID,
    "is_auto_generated" BOOLEAN NOT NULL DEFAULT false,
    "total_cost" DECIMAL(12,2),
    "total_volume" INTEGER,
    "city_count" INTEGER,
    "summary_data" JSONB,
    "excel_path" VARCHAR(500),
    "pdf_path" VARCHAR(500),
    "created_at" TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "generated_at" TIMESTAMPTZ,
    "expires_at" TIMESTAMPTZ,
    "error_message" TEXT,

    CONSTRAINT "monthly_reports_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "monthly_reports_month_type_key"
ON "monthly_reports"("report_month", "report_type");

CREATE INDEX "monthly_reports_month_idx" ON "monthly_reports"("report_month");
CREATE INDEX "monthly_reports_status_idx" ON "monthly_reports"("status");

-- AddForeignKey
ALTER TABLE "monthly_reports"
ADD CONSTRAINT "monthly_reports_generated_by_fkey"
FOREIGN KEY ("generated_by") REFERENCES "users"("id") ON DELETE SET NULL;
```

---

## 3. 類型定義

### 3.1 報告數據類型

```typescript
// src/types/monthly-report.ts

export interface MonthlyReportData {
  reportMonth: string;  // YYYY-MM
  generatedAt: string;

  summary: MonthlyReportSummary;
  cityBreakdown: CityBreakdownItem[];
  apiCostBreakdown: ApiCostBreakdownItem[];
  dailyTrend: DailyTrendItem[];
}

export interface MonthlyReportSummary {
  totalCost: number;
  totalVolume: number;
  totalAiCost: number;
  totalLaborCost: number;
  avgCostPerDocument: number;
  cityCount: number;
  comparedToPreviousMonth: {
    costChange: number;      // percentage
    volumeChange: number;    // percentage
    costPerDocChange: number;
  };
}

export interface CityBreakdownItem {
  cityCode: string;
  cityName: string;
  regionName?: string;
  volume: number;
  volumePercentage: number;
  aiCost: number;
  laborCost: number;
  totalCost: number;
  costPercentage: number;
  costPerDocument: number;
  comparedToPreviousMonth: {
    costChange: number;
    volumeChange: number;
  };
}

export interface ApiCostBreakdownItem {
  provider: string;
  calls: number;
  tokens: { input: number; output: number };
  cost: number;
  percentage: number;
}

export interface DailyTrendItem {
  date: string;
  volume: number;
  cost: number;
}
```

### 3.2 API 請求/響應類型

```typescript
// src/types/monthly-report.ts

export interface MonthlyReportGenerateRequest {
  month: string;  // YYYY-MM
  formats: ('excel' | 'pdf')[];
  sendNotification?: boolean;
}

export interface MonthlyReportRecord {
  id: string;
  reportMonth: string;
  status: ReportStatus;
  totalCost?: number;
  totalVolume?: number;
  cityCount?: number;
  excelAvailable: boolean;
  pdfAvailable: boolean;
  generatedAt?: string;
  generatedBy?: string;
  generatedByName?: string;
  isAutoGenerated: boolean;
  errorMessage?: string;
  createdAt: string;
}

export type ReportStatus = 'PENDING' | 'GENERATING' | 'COMPLETED' | 'FAILED';

export interface MonthlyReportListResponse {
  success: boolean;
  data: MonthlyReportRecord[];
  pagination: {
    total: number;
    page: number;
    pageSize: number;
  };
}

export interface ReportDownloadResponse {
  success: boolean;
  data: {
    downloadUrl: string;
    expiresAt: string;
    fileName: string;
  };
}
```

---

## 4. 後端服務實現

### 4.1 月度報告服務

```typescript
// src/services/monthly-cost-report.service.ts

import { prisma } from '@/lib/prisma';
import { uploadToBlob, generateSignedUrl } from '@/lib/azure-blob';
import { MonthlyReportData, MonthlyReportRecord, ReportStatus } from '@/types/monthly-report';
import ExcelJS from 'exceljs';
import PDFDocument from 'pdfkit';

export class MonthlyCostReportService {
  private static instance: MonthlyCostReportService;

  static getInstance(): MonthlyCostReportService {
    if (!this.instance) {
      this.instance = new MonthlyCostReportService();
    }
    return this.instance;
  }

  /**
   * 生成月度報告
   */
  async generateReport(
    month: string,
    formats: ('excel' | 'pdf')[],
    generatedBy?: string,
    isAutoGenerated = false
  ): Promise<MonthlyReportRecord> {
    const { startDate, endDate } = this.parseMonth(month);

    // 創建或更新報告記錄
    const report = await prisma.monthlyReport.upsert({
      where: {
        reportMonth_reportType: {
          reportMonth: startDate,
          reportType: 'COST_ALLOCATION'
        }
      },
      create: {
        reportMonth: startDate,
        status: 'GENERATING',
        generatedBy,
        isAutoGenerated
      },
      update: {
        status: 'GENERATING',
        generatedBy,
        isAutoGenerated,
        errorMessage: null
      }
    });

    try {
      // 收集報告數據
      const reportData = await this.collectReportData(startDate, endDate);

      // 生成檔案
      const { excelPath, pdfPath } = await this.generateReportFiles(
        reportData,
        month,
        formats
      );

      // 更新報告記錄
      const expiresAt = new Date();
      expiresAt.setDate(expiresAt.getDate() + 90);

      const updated = await prisma.monthlyReport.update({
        where: { id: report.id },
        data: {
          status: 'COMPLETED',
          totalCost: reportData.summary.totalCost,
          totalVolume: reportData.summary.totalVolume,
          cityCount: reportData.summary.cityCount,
          summaryData: reportData.summary as any,
          excelPath,
          pdfPath,
          generatedAt: new Date(),
          expiresAt
        },
        include: { generatedByUser: { select: { name: true } } }
      });

      return this.toReportRecord(updated);
    } catch (error) {
      await prisma.monthlyReport.update({
        where: { id: report.id },
        data: {
          status: 'FAILED',
          errorMessage: error instanceof Error ? error.message : 'Unknown error'
        }
      });
      throw error;
    }
  }

  /**
   * 收集報告數據
   */
  private async collectReportData(
    startDate: Date,
    endDate: Date
  ): Promise<MonthlyReportData> {
    const [cities, cityStats, apiStats, dailyTrend, prevMonthStats] =
      await Promise.all([
        prisma.city.findMany({ include: { region: { select: { name: true } } } }),
        this.getCityStats(startDate, endDate),
        this.getApiStats(startDate, endDate),
        this.getDailyTrend(startDate, endDate),
        this.getPreviousMonthStats(startDate)
      ]);

    // 計算總覽
    const totalCost = cityStats.reduce((sum, c) => sum + c.totalCost, 0);
    const totalVolume = cityStats.reduce((sum, c) => sum + c.volume, 0);
    const totalAiCost = cityStats.reduce((sum, c) => sum + c.aiCost, 0);
    const totalLaborCost = cityStats.reduce((sum, c) => sum + c.laborCost, 0);

    // 組裝城市明細
    const cityMap = new Map(cities.map(c => [c.code, c]));
    const cityBreakdown = cityStats.map(stat => {
      const city = cityMap.get(stat.cityCode);
      const prevCity = prevMonthStats.cities.find(p => p.cityCode === stat.cityCode);

      return {
        cityCode: stat.cityCode,
        cityName: city?.name || stat.cityCode,
        regionName: city?.region?.name,
        volume: stat.volume,
        volumePercentage: totalVolume > 0 ? (stat.volume / totalVolume) * 100 : 0,
        aiCost: stat.aiCost,
        laborCost: stat.laborCost,
        totalCost: stat.totalCost,
        costPercentage: totalCost > 0 ? (stat.totalCost / totalCost) * 100 : 0,
        costPerDocument: stat.volume > 0 ? stat.totalCost / stat.volume : 0,
        comparedToPreviousMonth: {
          costChange: prevCity?.totalCost
            ? ((stat.totalCost - prevCity.totalCost) / prevCity.totalCost) * 100
            : 0,
          volumeChange: prevCity?.volume
            ? ((stat.volume - prevCity.volume) / prevCity.volume) * 100
            : 0
        }
      };
    }).sort((a, b) => b.totalCost - a.totalCost);

    const avgCostPerDocument = totalVolume > 0 ? totalCost / totalVolume : 0;

    return {
      reportMonth: this.formatMonth(startDate),
      generatedAt: new Date().toISOString(),
      summary: {
        totalCost,
        totalVolume,
        totalAiCost,
        totalLaborCost,
        avgCostPerDocument,
        cityCount: cityBreakdown.length,
        comparedToPreviousMonth: {
          costChange: prevMonthStats.totalCost > 0
            ? ((totalCost - prevMonthStats.totalCost) / prevMonthStats.totalCost) * 100
            : 0,
          volumeChange: prevMonthStats.totalVolume > 0
            ? ((totalVolume - prevMonthStats.totalVolume) / prevMonthStats.totalVolume) * 100
            : 0,
          costPerDocChange: prevMonthStats.avgCostPerDoc > 0
            ? ((avgCostPerDocument - prevMonthStats.avgCostPerDoc) / prevMonthStats.avgCostPerDoc) * 100
            : 0
        }
      },
      cityBreakdown,
      apiCostBreakdown: apiStats,
      dailyTrend
    };
  }

  /**
   * 獲取城市統計
   */
  private async getCityStats(startDate: Date, endDate: Date) {
    const stats = await prisma.$queryRaw<Array<{
      cityCode: string;
      volume: bigint;
      aiCost: number;
    }>>`
      SELECT
        city_code as "cityCode",
        COUNT(*)::bigint as volume,
        COALESCE(SUM(ai_cost), 0)::float as "aiCost"
      FROM documents
      WHERE created_at >= ${startDate} AND created_at <= ${endDate}
      GROUP BY city_code
    `;

    return stats.map(s => ({
      cityCode: s.cityCode,
      volume: Number(s.volume),
      aiCost: s.aiCost,
      laborCost: this.estimateLaborCost(Number(s.volume)),
      totalCost: s.aiCost + this.estimateLaborCost(Number(s.volume))
    }));
  }

  /**
   * 估算人工成本
   */
  private estimateLaborCost(volume: number): number {
    const COST_PER_MANUAL_REVIEW = 0.50;
    const MANUAL_REVIEW_RATE = 0.15;  // 15% 需要人工審核
    return volume * MANUAL_REVIEW_RATE * COST_PER_MANUAL_REVIEW;
  }

  /**
   * 獲取 API 統計
   */
  private async getApiStats(startDate: Date, endDate: Date) {
    const stats = await prisma.apiUsageLog.groupBy({
      by: ['provider'],
      where: { createdAt: { gte: startDate, lte: endDate } },
      _sum: { estimatedCost: true, tokensInput: true, tokensOutput: true },
      _count: { id: true }
    });

    const total = stats.reduce((sum, s) => sum + (s._sum.estimatedCost || 0), 0);

    return stats.map(s => ({
      provider: s.provider,
      calls: s._count.id,
      tokens: {
        input: s._sum.tokensInput || 0,
        output: s._sum.tokensOutput || 0
      },
      cost: s._sum.estimatedCost || 0,
      percentage: total > 0 ? ((s._sum.estimatedCost || 0) / total) * 100 : 0
    }));
  }

  /**
   * 獲取每日趨勢
   */
  private async getDailyTrend(startDate: Date, endDate: Date) {
    const trend = await prisma.$queryRaw<Array<{
      date: Date;
      volume: bigint;
      cost: number;
    }>>`
      SELECT
        DATE(created_at) as date,
        COUNT(*)::bigint as volume,
        COALESCE(SUM(ai_cost), 0)::float as cost
      FROM documents
      WHERE created_at >= ${startDate} AND created_at <= ${endDate}
      GROUP BY DATE(created_at)
      ORDER BY date
    `;

    return trend.map(t => ({
      date: t.date.toISOString().split('T')[0],
      volume: Number(t.volume),
      cost: t.cost
    }));
  }

  /**
   * 獲取上月統計
   */
  private async getPreviousMonthStats(currentMonthStart: Date) {
    const prevStart = new Date(currentMonthStart);
    prevStart.setMonth(prevStart.getMonth() - 1);
    const prevEnd = new Date(currentMonthStart);
    prevEnd.setDate(prevEnd.getDate() - 1);
    prevEnd.setHours(23, 59, 59, 999);

    const cityStats = await this.getCityStats(prevStart, prevEnd);
    const totalCost = cityStats.reduce((sum, c) => sum + c.totalCost, 0);
    const totalVolume = cityStats.reduce((sum, c) => sum + c.volume, 0);

    return {
      totalCost,
      totalVolume,
      avgCostPerDoc: totalVolume > 0 ? totalCost / totalVolume : 0,
      cities: cityStats
    };
  }

  /**
   * 生成報告檔案
   */
  private async generateReportFiles(
    data: MonthlyReportData,
    month: string,
    formats: ('excel' | 'pdf')[]
  ): Promise<{ excelPath?: string; pdfPath?: string }> {
    let excelPath: string | undefined;
    let pdfPath: string | undefined;

    if (formats.includes('excel')) {
      const buffer = await this.generateExcelReport(data);
      excelPath = await uploadToBlob(
        buffer,
        `monthly-cost-${month}.xlsx`,
        'reports'
      );
    }

    if (formats.includes('pdf')) {
      const buffer = await this.generatePdfReport(data);
      pdfPath = await uploadToBlob(
        buffer,
        `monthly-cost-${month}.pdf`,
        'reports'
      );
    }

    return { excelPath, pdfPath };
  }

  /**
   * 獲取報告歷史
   */
  async getReportHistory(
    page = 1,
    pageSize = 12
  ): Promise<{ reports: MonthlyReportRecord[]; total: number }> {
    const [reports, total] = await Promise.all([
      prisma.monthlyReport.findMany({
        where: { reportType: 'COST_ALLOCATION' },
        orderBy: { reportMonth: 'desc' },
        skip: (page - 1) * pageSize,
        take: pageSize,
        include: { generatedByUser: { select: { name: true } } }
      }),
      prisma.monthlyReport.count({
        where: { reportType: 'COST_ALLOCATION' }
      })
    ]);

    return {
      reports: reports.map(r => this.toReportRecord(r)),
      total
    };
  }

  /**
   * 獲取下載連結
   */
  async getDownloadUrl(
    reportId: string,
    format: 'excel' | 'pdf'
  ): Promise<{ url: string; fileName: string; expiresAt: Date } | null> {
    const report = await prisma.monthlyReport.findUnique({
      where: { id: reportId }
    });

    if (!report || report.status !== 'COMPLETED') return null;

    const path = format === 'excel' ? report.excelPath : report.pdfPath;
    if (!path) return null;

    const expiresAt = new Date();
    expiresAt.setHours(expiresAt.getHours() + 1);

    const month = this.formatMonth(report.reportMonth);
    const fileName = `monthly-cost-${month}.${format === 'excel' ? 'xlsx' : 'pdf'}`;

    return {
      url: await generateSignedUrl(path, expiresAt),
      fileName,
      expiresAt
    };
  }

  // Helper methods
  private parseMonth(month: string): { startDate: Date; endDate: Date } {
    const [year, monthNum] = month.split('-').map(Number);
    const startDate = new Date(year, monthNum - 1, 1);
    const endDate = new Date(year, monthNum, 0, 23, 59, 59, 999);
    return { startDate, endDate };
  }

  private formatMonth(date: Date): string {
    return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
  }

  private toReportRecord(report: any): MonthlyReportRecord {
    return {
      id: report.id,
      reportMonth: this.formatMonth(report.reportMonth),
      status: report.status,
      totalCost: report.totalCost,
      totalVolume: report.totalVolume,
      cityCount: report.cityCount,
      excelAvailable: !!report.excelPath,
      pdfAvailable: !!report.pdfPath,
      generatedAt: report.generatedAt?.toISOString(),
      generatedBy: report.generatedBy,
      generatedByName: report.generatedByUser?.name,
      isAutoGenerated: report.isAutoGenerated,
      errorMessage: report.errorMessage,
      createdAt: report.createdAt.toISOString()
    };
  }

  // Excel/PDF generation methods in next section...
}

export const monthlyCostReportService = MonthlyCostReportService.getInstance();
```

### 4.2 Excel 報告生成器

```typescript
// src/services/monthly-cost-report.service.ts (continued)

/**
 * 生成 Excel 報告
 */
private async generateExcelReport(data: MonthlyReportData): Promise<Buffer> {
  const workbook = new ExcelJS.Workbook();
  workbook.creator = 'AI Document Extraction System';
  workbook.created = new Date();

  // 1. 摘要工作表
  this.buildSummarySheet(workbook.addWorksheet('摘要'), data);

  // 2. 城市明細工作表
  this.buildCitySheet(workbook.addWorksheet('城市明細'), data);

  // 3. API 成本工作表
  this.buildApiSheet(workbook.addWorksheet('API 成本'), data);

  // 4. 每日趨勢工作表
  this.buildTrendSheet(workbook.addWorksheet('每日趨勢'), data);

  return Buffer.from(await workbook.xlsx.writeBuffer());
}

private buildSummarySheet(sheet: ExcelJS.Worksheet, data: MonthlyReportData) {
  // 標題
  sheet.mergeCells('A1:C1');
  sheet.getCell('A1').value = `月度成本分攤報告 - ${data.reportMonth}`;
  sheet.getCell('A1').font = { bold: true, size: 16 };
  sheet.getCell('A1').alignment = { horizontal: 'center' };

  // 表頭
  sheet.getRow(3).values = ['指標', '數值', '較上月'];
  sheet.getRow(3).font = { bold: true };
  sheet.getRow(3).fill = {
    type: 'pattern',
    pattern: 'solid',
    fgColor: { argb: 'FFE0E0E0' }
  };

  // 數據行
  const rows = [
    ['總成本 (USD)', `$${data.summary.totalCost.toFixed(2)}`,
     `${data.summary.comparedToPreviousMonth.costChange >= 0 ? '+' : ''}${data.summary.comparedToPreviousMonth.costChange.toFixed(1)}%`],
    ['總處理量', data.summary.totalVolume.toLocaleString(),
     `${data.summary.comparedToPreviousMonth.volumeChange >= 0 ? '+' : ''}${data.summary.comparedToPreviousMonth.volumeChange.toFixed(1)}%`],
    ['AI 成本', `$${data.summary.totalAiCost.toFixed(2)}`, ''],
    ['人工成本（估算）', `$${data.summary.totalLaborCost.toFixed(2)}`, ''],
    ['平均單位成本', `$${data.summary.avgCostPerDocument.toFixed(4)}`,
     `${data.summary.comparedToPreviousMonth.costPerDocChange >= 0 ? '+' : ''}${data.summary.comparedToPreviousMonth.costPerDocChange.toFixed(1)}%`],
    ['城市數', data.summary.cityCount.toString(), '']
  ];

  rows.forEach((row, i) => {
    sheet.getRow(i + 4).values = row;
  });

  // 設置列寬
  sheet.columns = [
    { width: 25 },
    { width: 20 },
    { width: 15 }
  ];
}

private buildCitySheet(sheet: ExcelJS.Worksheet, data: MonthlyReportData) {
  sheet.columns = [
    { header: '城市', key: 'cityName', width: 20 },
    { header: '區域', key: 'regionName', width: 15 },
    { header: '處理量', key: 'volume', width: 12 },
    { header: '處理量占比', key: 'volumePct', width: 12 },
    { header: 'AI 成本', key: 'aiCost', width: 12 },
    { header: '人工成本', key: 'laborCost', width: 12 },
    { header: '總成本', key: 'totalCost', width: 12 },
    { header: '成本占比', key: 'costPct', width: 12 },
    { header: '單位成本', key: 'costPerDoc', width: 12 },
    { header: '成本變化', key: 'costChange', width: 12 }
  ];

  data.cityBreakdown.forEach(city => {
    sheet.addRow({
      cityName: city.cityName,
      regionName: city.regionName || '',
      volume: city.volume,
      volumePct: `${city.volumePercentage.toFixed(1)}%`,
      aiCost: `$${city.aiCost.toFixed(2)}`,
      laborCost: `$${city.laborCost.toFixed(2)}`,
      totalCost: `$${city.totalCost.toFixed(2)}`,
      costPct: `${city.costPercentage.toFixed(1)}%`,
      costPerDoc: `$${city.costPerDocument.toFixed(4)}`,
      costChange: `${city.comparedToPreviousMonth.costChange >= 0 ? '+' : ''}${city.comparedToPreviousMonth.costChange.toFixed(1)}%`
    });
  });

  // 樣式
  sheet.getRow(1).font = { bold: true };
  sheet.getRow(1).fill = {
    type: 'pattern',
    pattern: 'solid',
    fgColor: { argb: 'FFE0E0E0' }
  };

  // 篩選
  sheet.autoFilter = { from: 'A1', to: 'J1' };
}

private buildApiSheet(sheet: ExcelJS.Worksheet, data: MonthlyReportData) {
  sheet.columns = [
    { header: 'API 供應商', key: 'provider', width: 25 },
    { header: '調用次數', key: 'calls', width: 15 },
    { header: '輸入 Tokens', key: 'tokensInput', width: 15 },
    { header: '輸出 Tokens', key: 'tokensOutput', width: 15 },
    { header: '成本 (USD)', key: 'cost', width: 15 },
    { header: '占比', key: 'percentage', width: 10 }
  ];

  data.apiCostBreakdown.forEach(api => {
    sheet.addRow({
      provider: api.provider,
      calls: api.calls.toLocaleString(),
      tokensInput: api.tokens.input.toLocaleString(),
      tokensOutput: api.tokens.output.toLocaleString(),
      cost: `$${api.cost.toFixed(2)}`,
      percentage: `${api.percentage.toFixed(1)}%`
    });
  });

  sheet.getRow(1).font = { bold: true };
  sheet.getRow(1).fill = {
    type: 'pattern',
    pattern: 'solid',
    fgColor: { argb: 'FFE0E0E0' }
  };
}

private buildTrendSheet(sheet: ExcelJS.Worksheet, data: MonthlyReportData) {
  sheet.columns = [
    { header: '日期', key: 'date', width: 15 },
    { header: '處理量', key: 'volume', width: 12 },
    { header: '成本 (USD)', key: 'cost', width: 15 }
  ];

  data.dailyTrend.forEach(day => {
    sheet.addRow({
      date: day.date,
      volume: day.volume,
      cost: `$${day.cost.toFixed(2)}`
    });
  });

  sheet.getRow(1).font = { bold: true };
}
```

### 4.3 PDF 報告生成器

```typescript
// src/services/monthly-cost-report.service.ts (continued)

/**
 * 生成 PDF 報告
 */
private async generatePdfReport(data: MonthlyReportData): Promise<Buffer> {
  return new Promise((resolve, reject) => {
    const chunks: Buffer[] = [];
    const doc = new PDFDocument({
      margin: 50,
      size: 'A4'
    });

    doc.on('data', chunk => chunks.push(chunk));
    doc.on('end', () => resolve(Buffer.concat(chunks)));
    doc.on('error', reject);

    // 標題頁
    this.buildPdfTitlePage(doc, data);

    // 摘要頁
    doc.addPage();
    this.buildPdfSummaryPage(doc, data);

    // 城市排名頁
    doc.addPage();
    this.buildPdfCityRankingPage(doc, data);

    // API 成本頁
    doc.addPage();
    this.buildPdfApiCostPage(doc, data);

    // 頁尾
    this.addPdfFooter(doc, data);

    doc.end();
  });
}

private buildPdfTitlePage(doc: PDFKit.PDFDocument, data: MonthlyReportData) {
  doc.fontSize(28)
     .font('Helvetica-Bold')
     .text('月度成本分攤報告', { align: 'center' });

  doc.moveDown(2);
  doc.fontSize(20)
     .font('Helvetica')
     .text(data.reportMonth, { align: 'center' });

  doc.moveDown(4);
  doc.fontSize(12)
     .text(`生成時間: ${new Date().toLocaleString('zh-TW')}`, { align: 'center' });
}

private buildPdfSummaryPage(doc: PDFKit.PDFDocument, data: MonthlyReportData) {
  doc.fontSize(18).font('Helvetica-Bold').text('執行摘要');
  doc.moveDown();

  const summaryItems = [
    { label: '總成本', value: `$${data.summary.totalCost.toFixed(2)}`,
      change: data.summary.comparedToPreviousMonth.costChange },
    { label: '總處理量', value: data.summary.totalVolume.toLocaleString(),
      change: data.summary.comparedToPreviousMonth.volumeChange },
    { label: 'AI 成本', value: `$${data.summary.totalAiCost.toFixed(2)}` },
    { label: '人工成本', value: `$${data.summary.totalLaborCost.toFixed(2)}` },
    { label: '平均單位成本', value: `$${data.summary.avgCostPerDocument.toFixed(4)}`,
      change: data.summary.comparedToPreviousMonth.costPerDocChange },
    { label: '城市數', value: data.summary.cityCount.toString() }
  ];

  doc.fontSize(12).font('Helvetica');
  summaryItems.forEach(item => {
    let text = `${item.label}: ${item.value}`;
    if (item.change !== undefined) {
      const sign = item.change >= 0 ? '+' : '';
      text += ` (${sign}${item.change.toFixed(1)}% 較上月)`;
    }
    doc.text(text);
    doc.moveDown(0.5);
  });
}

private buildPdfCityRankingPage(doc: PDFKit.PDFDocument, data: MonthlyReportData) {
  doc.fontSize(18).font('Helvetica-Bold').text('城市成本排名 (Top 15)');
  doc.moveDown();

  const top15 = data.cityBreakdown.slice(0, 15);
  doc.fontSize(10).font('Helvetica');

  top15.forEach((city, i) => {
    const rank = `${i + 1}.`.padEnd(4);
    const name = city.cityName.padEnd(15);
    const cost = `$${city.totalCost.toFixed(2)}`.padStart(12);
    const pct = `(${city.costPercentage.toFixed(1)}%)`.padStart(8);

    doc.text(`${rank}${name}${cost} ${pct}`);
    doc.moveDown(0.3);
  });
}

private buildPdfApiCostPage(doc: PDFKit.PDFDocument, data: MonthlyReportData) {
  doc.fontSize(18).font('Helvetica-Bold').text('API 成本明細');
  doc.moveDown();

  doc.fontSize(10).font('Helvetica');
  data.apiCostBreakdown.forEach(api => {
    doc.text(`${api.provider}:`);
    doc.text(`  調用次數: ${api.calls.toLocaleString()}`, { indent: 20 });
    doc.text(`  成本: $${api.cost.toFixed(2)} (${api.percentage.toFixed(1)}%)`, { indent: 20 });
    doc.moveDown(0.5);
  });
}

private addPdfFooter(doc: PDFKit.PDFDocument, data: MonthlyReportData) {
  const pages = doc.bufferedPageRange();
  for (let i = 0; i < pages.count; i++) {
    doc.switchToPage(i);
    doc.fontSize(8)
       .text(
         `AI Document Extraction System - ${data.reportMonth} | Page ${i + 1} of ${pages.count}`,
         50,
         doc.page.height - 30,
         { align: 'center', width: doc.page.width - 100 }
       );
  }
}
```

---

## 5. API 端點

### 5.1 報告生成 API

```typescript
// src/app/api/reports/monthly-cost/generate/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { auth } from '@/lib/auth';
import { monthlyCostReportService } from '@/services/monthly-cost-report.service';
import { z } from 'zod';

const generateSchema = z.object({
  month: z.string().regex(/^\d{4}-\d{2}$/, 'Format must be YYYY-MM'),
  formats: z.array(z.enum(['excel', 'pdf'])).min(1),
  sendNotification: z.boolean().optional()
});

export async function POST(request: NextRequest) {
  try {
    const session = await auth();
    if (!session?.user?.permissions?.includes('GENERATE_REPORTS')) {
      return NextResponse.json(
        { success: false, error: 'Permission denied' },
        { status: 403 }
      );
    }

    const body = await request.json();
    const { month, formats, sendNotification } = generateSchema.parse(body);

    // 驗證不能是未來月份
    const [year, monthNum] = month.split('-').map(Number);
    const now = new Date();
    if (year > now.getFullYear() ||
        (year === now.getFullYear() && monthNum > now.getMonth() + 1)) {
      return NextResponse.json(
        { success: false, error: 'Cannot generate report for future months' },
        { status: 400 }
      );
    }

    const report = await monthlyCostReportService.generateReport(
      month,
      formats,
      session.user.id,
      false
    );

    return NextResponse.json({ success: true, data: report });
  } catch (error) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { success: false, error: error.errors[0].message },
        { status: 400 }
      );
    }
    console.error('Monthly report generation error:', error);
    return NextResponse.json(
      { success: false, error: 'Failed to generate report' },
      { status: 500 }
    );
  }
}
```

### 5.2 報告歷史 API

```typescript
// src/app/api/reports/monthly-cost/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { auth } from '@/lib/auth';
import { monthlyCostReportService } from '@/services/monthly-cost-report.service';

export async function GET(request: NextRequest) {
  try {
    const session = await auth();
    if (!session?.user?.permissions?.includes('VIEW_REPORTS')) {
      return NextResponse.json(
        { success: false, error: 'Permission denied' },
        { status: 403 }
      );
    }

    const { searchParams } = new URL(request.url);
    const page = parseInt(searchParams.get('page') || '1');
    const pageSize = parseInt(searchParams.get('pageSize') || '12');

    const { reports, total } = await monthlyCostReportService.getReportHistory(
      page,
      pageSize
    );

    return NextResponse.json({
      success: true,
      data: reports,
      pagination: { total, page, pageSize }
    });
  } catch (error) {
    console.error('Get report history error:', error);
    return NextResponse.json(
      { success: false, error: 'Failed to get report history' },
      { status: 500 }
    );
  }
}
```

### 5.3 報告下載 API

```typescript
// src/app/api/reports/monthly-cost/[id]/download/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { auth } from '@/lib/auth';
import { monthlyCostReportService } from '@/services/monthly-cost-report.service';

export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await auth();
    if (!session?.user?.permissions?.includes('VIEW_REPORTS')) {
      return NextResponse.json(
        { success: false, error: 'Permission denied' },
        { status: 403 }
      );
    }

    const { searchParams } = new URL(request.url);
    const format = searchParams.get('format') as 'excel' | 'pdf';

    if (!format || !['excel', 'pdf'].includes(format)) {
      return NextResponse.json(
        { success: false, error: 'Invalid format parameter' },
        { status: 400 }
      );
    }

    const result = await monthlyCostReportService.getDownloadUrl(
      params.id,
      format
    );

    if (!result) {
      return NextResponse.json(
        { success: false, error: 'Report not found or not ready' },
        { status: 404 }
      );
    }

    return NextResponse.json({
      success: true,
      data: {
        downloadUrl: result.url,
        fileName: result.fileName,
        expiresAt: result.expiresAt.toISOString()
      }
    });
  } catch (error) {
    console.error('Get download URL error:', error);
    return NextResponse.json(
      { success: false, error: 'Failed to get download URL' },
      { status: 500 }
    );
  }
}
```

---

## 6. 前端組件

### 6.1 月份選擇對話框

```typescript
// src/components/reports/MonthlyReportDialog.tsx

'use client';

import { useState } from 'react';
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { CalendarIcon, Loader2, FileSpreadsheet, FileText } from 'lucide-react';
import { format, subMonths } from 'date-fns';
import { zhTW } from 'date-fns/locale';
import {
  Dialog, DialogContent, DialogDescription, DialogFooter,
  DialogHeader, DialogTitle, DialogTrigger
} from '@/components/ui/dialog';
import { Button } from '@/components/ui/button';
import { MonthPicker } from '@/components/ui/month-picker';
import { Checkbox } from '@/components/ui/checkbox';
import { Label } from '@/components/ui/label';
import { useToast } from '@/components/ui/use-toast';

interface MonthlyReportDialogProps {
  trigger?: React.ReactNode;
}

export function MonthlyReportDialog({ trigger }: MonthlyReportDialogProps) {
  const [open, setOpen] = useState(false);
  const [selectedDate, setSelectedDate] = useState<Date>(subMonths(new Date(), 1));
  const [formats, setFormats] = useState<('excel' | 'pdf')[]>(['excel', 'pdf']);
  const { toast } = useToast();
  const queryClient = useQueryClient();

  const generateMutation = useMutation({
    mutationFn: async () => {
      const month = format(selectedDate, 'yyyy-MM');
      const response = await fetch('/api/reports/monthly-cost/generate', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ month, formats })
      });

      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.error || 'Generation failed');
      }
      return response.json();
    },
    onSuccess: () => {
      toast({
        title: '報告生成成功',
        description: '月度成本分攤報告已生成，可在報告歷史中下載。'
      });
      queryClient.invalidateQueries({ queryKey: ['monthly-reports'] });
      setOpen(false);
    },
    onError: (error) => {
      toast({
        title: '生成失敗',
        description: error instanceof Error ? error.message : '請稍後再試',
        variant: 'destructive'
      });
    }
  });

  const toggleFormat = (fmt: 'excel' | 'pdf') => {
    setFormats(prev =>
      prev.includes(fmt) ? prev.filter(f => f !== fmt) : [...prev, fmt]
    );
  };

  return (
    <Dialog open={open} onOpenChange={setOpen}>
      <DialogTrigger asChild>
        {trigger || <Button>生成月度報告</Button>}
      </DialogTrigger>
      <DialogContent className="sm:max-w-md">
        <DialogHeader>
          <DialogTitle>生成月度成本分攤報告</DialogTitle>
          <DialogDescription>
            選擇月份和匯出格式，系統將生成詳細的成本分攤報告。
          </DialogDescription>
        </DialogHeader>

        <div className="space-y-4 py-4">
          <div className="space-y-2">
            <Label>選擇月份</Label>
            <MonthPicker
              selected={selectedDate}
              onSelect={setSelectedDate}
              maxDate={subMonths(new Date(), 0)}
              minDate={new Date(2023, 0, 1)}
            />
          </div>

          <div className="space-y-2">
            <Label>匯出格式</Label>
            <div className="flex gap-4">
              <div className="flex items-center space-x-2">
                <Checkbox
                  id="excel"
                  checked={formats.includes('excel')}
                  onCheckedChange={() => toggleFormat('excel')}
                />
                <label htmlFor="excel" className="flex items-center gap-1 text-sm cursor-pointer">
                  <FileSpreadsheet className="h-4 w-4 text-green-600" />
                  Excel
                </label>
              </div>
              <div className="flex items-center space-x-2">
                <Checkbox
                  id="pdf"
                  checked={formats.includes('pdf')}
                  onCheckedChange={() => toggleFormat('pdf')}
                />
                <label htmlFor="pdf" className="flex items-center gap-1 text-sm cursor-pointer">
                  <FileText className="h-4 w-4 text-red-600" />
                  PDF
                </label>
              </div>
            </div>
          </div>
        </div>

        <DialogFooter>
          <Button variant="outline" onClick={() => setOpen(false)}>
            取消
          </Button>
          <Button
            onClick={() => generateMutation.mutate()}
            disabled={generateMutation.isPending || formats.length === 0}
          >
            {generateMutation.isPending && (
              <Loader2 className="mr-2 h-4 w-4 animate-spin" />
            )}
            生成報告
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}
```

### 6.2 報告歷史頁面

```typescript
// src/app/(dashboard)/reports/monthly/page.tsx

'use client';

import { useQuery } from '@tanstack/react-query';
import { format } from 'date-fns';
import { zhTW } from 'date-fns/locale';
import { FileSpreadsheet, FileText, Download, Clock, User, Bot, AlertCircle } from 'lucide-react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { Skeleton } from '@/components/ui/skeleton';
import { MonthlyReportDialog } from '@/components/reports/MonthlyReportDialog';
import { MonthlyReportRecord } from '@/types/monthly-report';

export default function MonthlyReportsPage() {
  const { data, isLoading, error } = useQuery({
    queryKey: ['monthly-reports'],
    queryFn: async () => {
      const response = await fetch('/api/reports/monthly-cost');
      if (!response.ok) throw new Error('Failed to fetch reports');
      return response.json();
    }
  });

  const handleDownload = async (reportId: string, fmt: 'excel' | 'pdf') => {
    const response = await fetch(
      `/api/reports/monthly-cost/${reportId}/download?format=${fmt}`
    );
    if (response.ok) {
      const { data } = await response.json();
      window.open(data.downloadUrl, '_blank');
    }
  };

  if (error) {
    return (
      <div className="flex items-center justify-center h-64">
        <p className="text-destructive">載入報告歷史失敗</p>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-2xl font-bold">月度成本分攤報告</h1>
          <p className="text-muted-foreground">
            查看和下載歷史月度報告，或生成新的報告
          </p>
        </div>
        <MonthlyReportDialog />
      </div>

      <div className="grid gap-4">
        {isLoading ? (
          Array.from({ length: 3 }).map((_, i) => (
            <Card key={i}>
              <CardContent className="p-6">
                <Skeleton className="h-20 w-full" />
              </CardContent>
            </Card>
          ))
        ) : (
          data?.data?.map((report: MonthlyReportRecord) => (
            <ReportCard
              key={report.id}
              report={report}
              onDownload={handleDownload}
            />
          ))
        )}

        {!isLoading && data?.data?.length === 0 && (
          <Card>
            <CardContent className="p-12 text-center">
              <p className="text-muted-foreground">尚無報告記錄</p>
              <MonthlyReportDialog
                trigger={
                  <Button className="mt-4">生成第一份報告</Button>
                }
              />
            </CardContent>
          </Card>
        )}
      </div>
    </div>
  );
}

function ReportCard({
  report,
  onDownload
}: {
  report: MonthlyReportRecord;
  onDownload: (id: string, format: 'excel' | 'pdf') => void;
}) {
  return (
    <Card>
      <CardContent className="p-6">
        <div className="flex items-start justify-between">
          <div className="space-y-2">
            <div className="flex items-center gap-2">
              <h3 className="text-lg font-semibold">{report.reportMonth}</h3>
              <StatusBadge status={report.status} />
              {report.isAutoGenerated && (
                <Badge variant="outline" className="gap-1">
                  <Bot className="h-3 w-3" />
                  自動生成
                </Badge>
              )}
            </div>

            {report.status === 'COMPLETED' && (
              <div className="flex gap-4 text-sm text-muted-foreground">
                <span>總成本: ${report.totalCost?.toFixed(2)}</span>
                <span>處理量: {report.totalVolume?.toLocaleString()}</span>
                <span>城市數: {report.cityCount}</span>
              </div>
            )}

            <div className="flex items-center gap-4 text-xs text-muted-foreground">
              {report.generatedAt && (
                <span className="flex items-center gap-1">
                  <Clock className="h-3 w-3" />
                  {format(new Date(report.generatedAt), 'yyyy/MM/dd HH:mm', { locale: zhTW })}
                </span>
              )}
              {report.generatedByName && (
                <span className="flex items-center gap-1">
                  <User className="h-3 w-3" />
                  {report.generatedByName}
                </span>
              )}
            </div>

            {report.status === 'FAILED' && report.errorMessage && (
              <p className="text-sm text-destructive flex items-center gap-1">
                <AlertCircle className="h-4 w-4" />
                {report.errorMessage}
              </p>
            )}
          </div>

          {report.status === 'COMPLETED' && (
            <div className="flex gap-2">
              {report.excelAvailable && (
                <Button
                  variant="outline"
                  size="sm"
                  onClick={() => onDownload(report.id, 'excel')}
                >
                  <FileSpreadsheet className="h-4 w-4 mr-1 text-green-600" />
                  Excel
                </Button>
              )}
              {report.pdfAvailable && (
                <Button
                  variant="outline"
                  size="sm"
                  onClick={() => onDownload(report.id, 'pdf')}
                >
                  <FileText className="h-4 w-4 mr-1 text-red-600" />
                  PDF
                </Button>
              )}
            </div>
          )}
        </div>
      </CardContent>
    </Card>
  );
}

function StatusBadge({ status }: { status: string }) {
  const config = {
    COMPLETED: { label: '已完成', variant: 'default' as const },
    GENERATING: { label: '生成中', variant: 'secondary' as const },
    PENDING: { label: '待處理', variant: 'outline' as const },
    FAILED: { label: '失敗', variant: 'destructive' as const }
  };

  const { label, variant } = config[status as keyof typeof config] || config.PENDING;
  return <Badge variant={variant}>{label}</Badge>;
}
```

---

## 7. 排程任務

### 7.1 自動生成排程

```typescript
// src/jobs/monthly-report.job.ts

import { CronJob } from 'cron';
import { monthlyCostReportService } from '@/services/monthly-cost-report.service';
import { notificationService } from '@/services/notification.service';
import { format, subMonths } from 'date-fns';

const REPORT_GENERATION_DAY = process.env.MONTHLY_REPORT_DAY || '3';
const REPORT_GENERATION_HOUR = process.env.MONTHLY_REPORT_HOUR || '2';

// 每月指定日期凌晨自動生成上月報告
export const monthlyReportJob = new CronJob(
  `0 ${REPORT_GENERATION_HOUR} ${REPORT_GENERATION_DAY} * *`,
  async () => {
    const lastMonth = subMonths(new Date(), 1);
    const month = format(lastMonth, 'yyyy-MM');

    console.log(`[MonthlyReportJob] Starting auto-generation for ${month}`);

    try {
      const report = await monthlyCostReportService.generateReport(
        month,
        ['excel', 'pdf'],
        undefined,
        true  // isAutoGenerated
      );

      console.log(`[MonthlyReportJob] Report generated: ${report.id}`);

      // 通知財務團隊
      await notificationService.notifyByRole('FINANCE', {
        type: 'MONTHLY_REPORT_READY',
        title: `${month} 月度成本分攤報告已生成`,
        message: `總成本: $${report.totalCost?.toFixed(2)}, 處理量: ${report.totalVolume?.toLocaleString()}`,
        link: '/reports/monthly'
      });

    } catch (error) {
      console.error(`[MonthlyReportJob] Generation failed:`, error);

      // 通知管理員
      await notificationService.notifyByRole('ADMIN', {
        type: 'MONTHLY_REPORT_FAILED',
        title: `${month} 月度報告生成失敗`,
        message: error instanceof Error ? error.message : 'Unknown error',
        link: '/admin/jobs'
      });
    }
  },
  null,
  false,
  process.env.TZ || 'Asia/Taipei'
);

// 啟動排程
export function startMonthlyReportJob() {
  monthlyReportJob.start();
  console.log('[MonthlyReportJob] Scheduled job started');
}
```

### 7.2 排程初始化

```typescript
// src/lib/jobs/index.ts

import { monthlyReportJob, startMonthlyReportJob } from '@/jobs/monthly-report.job';

export function initializeJobs() {
  if (process.env.ENABLE_SCHEDULED_JOBS === 'true') {
    startMonthlyReportJob();
    console.log('[Jobs] All scheduled jobs initialized');
  }
}

export { monthlyReportJob };
```

---

## 8. 測試規格

### 8.1 單元測試

```typescript
// src/services/__tests__/monthly-cost-report.service.test.ts

import { describe, it, expect, vi, beforeEach } from 'vitest';
import { MonthlyCostReportService } from '../monthly-cost-report.service';
import { prisma } from '@/lib/prisma';

vi.mock('@/lib/prisma');
vi.mock('@/lib/azure-blob');

describe('MonthlyCostReportService', () => {
  let service: MonthlyCostReportService;

  beforeEach(() => {
    service = MonthlyCostReportService.getInstance();
    vi.clearAllMocks();
  });

  describe('generateReport', () => {
    it('should create report record with GENERATING status', async () => {
      vi.mocked(prisma.monthlyReport.upsert).mockResolvedValue({
        id: 'report-1',
        status: 'GENERATING'
      } as any);

      vi.mocked(prisma.city.findMany).mockResolvedValue([]);
      vi.mocked(prisma.$queryRaw).mockResolvedValue([]);
      vi.mocked(prisma.apiUsageLog.groupBy).mockResolvedValue([]);

      await service.generateReport('2024-01', ['excel'], 'user-1');

      expect(prisma.monthlyReport.upsert).toHaveBeenCalledWith(
        expect.objectContaining({
          create: expect.objectContaining({ status: 'GENERATING' })
        })
      );
    });

    it('should update status to FAILED on error', async () => {
      vi.mocked(prisma.monthlyReport.upsert).mockResolvedValue({
        id: 'report-1'
      } as any);
      vi.mocked(prisma.city.findMany).mockRejectedValue(new Error('DB error'));

      await expect(
        service.generateReport('2024-01', ['excel'])
      ).rejects.toThrow('DB error');

      expect(prisma.monthlyReport.update).toHaveBeenCalledWith(
        expect.objectContaining({
          data: expect.objectContaining({ status: 'FAILED' })
        })
      );
    });
  });

  describe('getReportHistory', () => {
    it('should return paginated reports', async () => {
      vi.mocked(prisma.monthlyReport.findMany).mockResolvedValue([
        { id: '1', reportMonth: new Date('2024-01-01') }
      ] as any);
      vi.mocked(prisma.monthlyReport.count).mockResolvedValue(1);

      const result = await service.getReportHistory(1, 10);

      expect(result.reports).toHaveLength(1);
      expect(result.total).toBe(1);
    });
  });
});
```

### 8.2 API 測試

```typescript
// src/app/api/reports/monthly-cost/__tests__/generate.test.ts

import { describe, it, expect, vi } from 'vitest';
import { POST } from '../generate/route';
import { NextRequest } from 'next/server';

vi.mock('@/lib/auth', () => ({
  auth: vi.fn()
}));

vi.mock('@/services/monthly-cost-report.service');

describe('POST /api/reports/monthly-cost/generate', () => {
  it('should return 403 without permission', async () => {
    const { auth } = await import('@/lib/auth');
    vi.mocked(auth).mockResolvedValue({
      user: { permissions: [] }
    } as any);

    const request = new NextRequest('http://localhost/api/reports/monthly-cost/generate', {
      method: 'POST',
      body: JSON.stringify({ month: '2024-01', formats: ['excel'] })
    });

    const response = await POST(request);
    expect(response.status).toBe(403);
  });

  it('should reject future month', async () => {
    const { auth } = await import('@/lib/auth');
    vi.mocked(auth).mockResolvedValue({
      user: { id: '1', permissions: ['GENERATE_REPORTS'] }
    } as any);

    const futureMonth = '2099-12';
    const request = new NextRequest('http://localhost/api/reports/monthly-cost/generate', {
      method: 'POST',
      body: JSON.stringify({ month: futureMonth, formats: ['excel'] })
    });

    const response = await POST(request);
    const data = await response.json();

    expect(response.status).toBe(400);
    expect(data.error).toContain('future');
  });
});
```

### 8.3 E2E 測試

```typescript
// e2e/monthly-report.spec.ts

import { test, expect } from '@playwright/test';

test.describe('Monthly Cost Report', () => {
  test.beforeEach(async ({ page }) => {
    await page.goto('/login');
    await page.fill('[name="email"]', 'finance@test.com');
    await page.fill('[name="password"]', 'password');
    await page.click('button[type="submit"]');
    await page.waitForURL('/dashboard');
  });

  test('should generate monthly report', async ({ page }) => {
    await page.goto('/reports/monthly');

    // 點擊生成報告按鈕
    await page.click('button:has-text("生成月度報告")');

    // 選擇月份
    await page.click('[data-testid="month-picker"]');
    await page.click('button:has-text("2024 年 1 月")');

    // 確認格式已選擇
    expect(await page.isChecked('#excel')).toBeTruthy();
    expect(await page.isChecked('#pdf')).toBeTruthy();

    // 生成報告
    await page.click('button:has-text("生成報告")');

    // 等待成功訊息
    await expect(page.locator('text=報告生成成功')).toBeVisible();
  });

  test('should download report', async ({ page }) => {
    await page.goto('/reports/monthly');

    // 等待報告列表載入
    await page.waitForSelector('[data-testid="report-card"]');

    // 下載 Excel
    const [download] = await Promise.all([
      page.waitForEvent('download'),
      page.click('button:has-text("Excel")')
    ]);

    expect(download.suggestedFilename()).toContain('.xlsx');
  });
});
```

---

## 9. 驗收標準對照

| AC | 描述 | 實現方式 |
|----|------|----------|
| AC1 | 月度報告生成入口 | MonthlyReportDialog 月份選擇對話框 |
| AC2 | 報告內容完整性 | collectReportData 聚合城市統計、API成本、分攤比例、月度對比 |
| AC3 | 多格式匯出 | generateExcelReport + generatePdfReport 支援 Excel/PDF |
| AC4 | 報告歷史管理 | getReportHistory + MonthlyReportsPage 歷史列表與重新下載 |
| AC5 | 自動生成排程 | monthlyReportJob cron 任務 + 通知財務人員 |

---

## 10. 部署注意事項

### 10.1 環境變數

```env
# 排程配置
ENABLE_SCHEDULED_JOBS=true
MONTHLY_REPORT_DAY=3        # 每月第幾天生成
MONTHLY_REPORT_HOUR=2       # 凌晨幾點生成
TZ=Asia/Taipei

# Azure Blob Storage
AZURE_STORAGE_CONNECTION_STRING=...
AZURE_STORAGE_CONTAINER_REPORTS=reports
```

### 10.2 依賴套件

```json
{
  "dependencies": {
    "exceljs": "^4.4.0",
    "pdfkit": "^0.15.0",
    "cron": "^3.1.0"
  },
  "devDependencies": {
    "@types/pdfkit": "^0.13.0"
  }
}
```

### 10.3 權限配置

```typescript
// 需要的權限
const REQUIRED_PERMISSIONS = {
  generate: ['GENERATE_REPORTS'],  // 財務人員、管理員
  view: ['VIEW_REPORTS'],          // 財務人員、管理員、區域經理
  download: ['VIEW_REPORTS']
};
```

---

## 11. 相關文件

- [Story 7-7: 城市處理數量追蹤](./tech-spec-story-7-7.md)
- [Story 7-8: 城市 AI 成本追蹤](./tech-spec-story-7-8.md)
- [Story 7-9: 城市成本報表](./tech-spec-story-7-9.md)
- [Epic 7: 報表儀表板與成本追蹤](../03-epics/sections/epic-7-reports-dashboard-cost-tracking.md)
- [PRD FR72: 月度成本報告](../01-planning/prd/sections/functional-requirements.md#FR72)
